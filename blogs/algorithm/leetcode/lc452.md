---
title: 452. 用最少数量的箭引爆气球(补作业)
date: 2020-11-25
sidebar: "auto"
categories:
  - algorithm
tags:
  - leetcode
  - 贪心
---

## 题目

<img :src="$withBase('/leetcodeImages/lc452.png')" alt="leetcode452">

&emsp;&emsp;这道题题目较长，其大意我概括一下，就是给你了很多 X 轴上的区间，让你在 X 轴少找一些点，使这些点能覆盖到所有区间，求最少的点的个数。

## 题目分析

&emsp;&emsp;其实这个题是贪心算法的典型题目，如果之前有接触到活动(课程)排期之类的题目的人肯定可以想出来，因为这都是一类问题。如果之前没接触过这类问题也不要慌，我带大家来推理下这类问题。  
&emsp;&emsp;可以参加之前做过的 lc406 问题，这两个问题还是有一些相似之处，比如我在哪个问题中说了，对于序列加上多重因素（如 lc406 中的身高和数目，这里的起始坐标和结束坐标）的情况，我们可以首先考虑排序，排序可以将问题简单化，但是排序的话要看以哪个为主要因素进行排序（如何排序）。  
&emsp;&emsp;这里我就直说了，可以以起始坐标排序，也可以以结束坐标排序，还可以以区间长度进行排序。很显然这里以区间长度排序没有任何意义，那么如果以起始坐标进行排序，后续该如何遍历呢？可以自己想一下或者找数据模拟一下。如果找到了第一个区间，那么后续的区间的起始坐标如果在第一个区间的结束坐标内是不是就可以归纳到一起，意思就是可以用这个区间内的一个点来覆盖这两个区间。但是考虑这样一组数据，[1,12],[3,6],[7,10]。这样的话按照上面的思想用一个点就能覆盖三个区间，实际上需要两个点。出错的地方在于第二个区间和第三个区间的结束坐标没有超过第一个区间，这样即使第二个区间和第三个区间的起始坐标在第一个区间的范围内，你也不能保证就存在一个点一定能够覆盖这些区间。知道出错的原因就好办了，出错是结束坐标大小没有固定，那我们就给结束坐标排序，这样再用上面的思想就可以完成了。还有一个小细节就是在遍历当前区间的时候，我会向后遍历起始坐标小于它自身结束坐标的区间，这样当遇到不满足要求的区间，下一次可以直接从哪个区间开始遍历，这样就不需要二重循环，直接变为一次遍历即可。

## 代码

```cpp  代码
    int findMinArrowShots(vector<vector<int>>& points) {
        if(points.empty()) {
            return 0;
        }
        sort(points.begin(), points.end(),[](const vector<int>& a ,const vector<int>& b){
            return a[1]<b[1];
        });
        int count = 1;
        int deadline = points[0][1];
        for (const vector<int>& p: points) {
           if(p[0] > deadline) {
               deadline = p[1];
               count++;
           }
        }
        return count;
    }
```

## 总结

&emsp;&emsp; 贪心算法，这是一类问题，多积累！
